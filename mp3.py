import subprocess
import re
import os
import shutil
import json
import argparse
import datetime
from pathlib import Path
from PIL import Image

# TODO:
# delete temporary files if --keep not specified
# grab number of frames from timestamp, and allow user to specify which one to keep
# use audio target video as frame cover art target if none is specified
# some way to move dims of cropped image (prereq gui?)
# check if thumbnail as cover art still works

'''
Attempts to determine and get the video path that yt-mp3 downloaded.
We don't know what format yt-mp3 downlaoded, so we simply try all until file is found.
'''
def try_get_downloaded_video_path(video_id: str) -> str:
    video_formats: list[str] = [
        "webm",
        "mp4"
    ]

    for format in video_formats:
        str_path = f"./{video_id}.{format}"
        if Path(str_path).exists():
            return str_path

    return None

'''
Parses a youtube url, returning its id
'''
def parse_url(url: str):
    url_result_groups = re.search(r'^.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#\&\?]*).*$', url).groups()
    if not url_result_groups or len(url_result_groups) > 1:
        raise ValueError(f"Error parsing URL {url}")
    return url_result_groups[0]


'''
Returns a youtube url from a video id
'''
def url(id: str):
    return f'https://www.youtube.com/watch?v={id}'


'''
Downloads the audio, video, thumbnail, metadata json, and description of a video.
Args:
    video_id: The id of the video to download content for.

TODO:
    return the various paths for outputs of this method.
'''
def download_content(video_id: str):
    yt_dlp_command = ['yt-dlp',
        '-x',                               # extract audio
        '-k',                               # keep video
        '-o', '%(id)s.%(ext)s',             # set audio path to [youtube id].[extension]
        '--write-thumbnail',                # get thumbnail
        '--convert-thumbnails', 'png',      # convert thumbnail to png
        '--write-description',              # get description
        '--audio-format', 'mp3',            # convert audio to mp3
        '--audio-quality', '0',             # highest quality audio
        '--write-info-json',                # get metadata json
        f'{url(video_id)}',                 # youtube video url
    ]
    subprocess.run(yt_dlp_command, check=True)


'''
Checks if a youtube is autogenerated
'''
def is_autogenerated_video(description_path: str):
    description_str = None
    with open(description_path, mode='r', encoding='utf-8') as description_file:
        description_str = description_file.read()

    if description_str and re.match(r'^[\S\s]*Auto-generated by YouTube\.$', description_str):
        return True
    return False


'''
Gets a frame of a video from a given timestamp as an image
'''
def get_frame(video_path: str, frame_path: str, time: datetime.time):
    if not time:
        time = datetime.time(0, 0, 1)

    seek_time = f'00:{time.minute:02}:{time.second:02}'

    ffmpeg_get_frame_command = ['ffmpeg',
        '-ss', seek_time,
        '-i', video_path,
        '-vframes', '1', # ensure only 1 frame is extracted
        f'{frame_path}'
    ]
    subprocess.run(ffmpeg_get_frame_command, check=True)

'''
Crops a image, saving it as "{image_path}_cropped.png".
Return path of cropped image.
'''
def crop_image(image_path: str):
    image = Image.open(image_path)
    offset = (max(image.size) - min(image.size)) // 2
    if image.size[0] >= image.size[1]: # width >= height
        crop_dims = (offset, 0, min(image.size) + offset, min(image.size))
    else: # height > width
        crop_dims = (0, offset, min(image.size), min(image.size) + offset)

    cropped_image = image.crop(crop_dims)
    image_path_stem = Path(image_path).stem
    cropped_image_path = f"{image_path_stem}_cropped.png"
    cropped_image.save(cropped_image_path)

    return cropped_image_path

'''
Reads a video metadata info json file and sets the tag of an audio file
based on the first key it encounters in the json
'''
def set_metadata(metadata, audio_path, tag, *keys):
    value = None
    for key in keys:
        if key in metadata:
            value = metadata[key]
            break
    if value:
        subprocess.run(['eyeD3', f'--{tag}', f"{value}", f'{audio_path}'], check=True)

'''
Formats the argument timestamp into time object
Expects format mm:ss or m:ss
'''
def get_timestamp(input_timestamp):
    if not input_timestamp:
        return None
    return datetime.datetime.strptime(input_timestamp, '%M:%S')

'''
Based parameters specified, will generate and set an image to be used as coverart.
- If a cover_art_url is specified, will pull a frame from the video specified by the url
- If the audio target video is autogenerated or the timestamp is specified, will pull a frame from the audio video
- Otherwise, will use the audio target video thumbnail
- Will crop the cover art to be square unless nocrop is specified
'''
def generate_cover_art(
        audio_path: str,
        video_id: str,
        cover_art_url: str,
        nocrop: bool,
        timestamp: datetime.time):

    is_autogenerated = is_autogenerated_video(f'{video_id}.description')

    if cover_art_url:
        # get cover art from other video frame
        cover_art_id = parse_url(cover_art_url)
        download_content(cover_art_id)
        cover_art_path = f'./frame_{cover_art_id}.png'
        video_path = try_get_downloaded_video_path(cover_art_id)
        get_frame(video_path, cover_art_path, timestamp)
    elif is_autogenerated or timestamp:
        # get cover art from current video frame
        cover_art_path = f'./frame_{video_id}.png'
        video_path = try_get_downloaded_video_path(video_id)
        get_frame(video_path, cover_art_path, timestamp)
    else:
        # use thumbnail as cover art
        cover_art_path = f'./{video_id}.png'

    # crop image thumbnail to be a square
    if not nocrop:
        cover_art_path = crop_image(cover_art_path)

    # set cover art metadata
    eyed3_cover_art_command = ['eyeD3',
        '--add-image', f'{cover_art_path}:FRONT_COVER',
        f'{audio_path}'
    ]
    subprocess.run(eyed3_cover_art_command, check=True)

'''
Gets and parses arguments.
Returns parsed arguments.
'''
def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('url')
    parser.add_argument('-c',
                        '--cover-art',
                        metavar='cover-url',
                        help='''Sets the cover art to the first frame of a given cover art target video,
                        optionally different from the audio target video.''')
    parser.add_argument('-k',
                        '--keep',
                        help='Keep temporary files',
                        action='store_true')
    parser.add_argument('-t',
                        '--timestamp',
                        help='Specify timestamp for cover art target video')
    parser.add_argument('--nocrop',
                        action='store_true')
    return parser.parse_args()

def main():
    # Parse args
    args = get_arguments()


    # Get video id
    video_id = parse_url(args.url)
    print(video_id)


    # create and move into temporary directory
    tempdir_path = f'./{video_id}'
    os.mkdir(tempdir_path)
    os.chdir(tempdir_path)


    # download audio
    audio_path = f'./{video_id}.mp3'
    download_content(video_id)


    # generate and set cover art
    generate_cover_art(
        audio_path,
        video_id=video_id,
        cover_art_url=args.cover_art,
        nocrop=args.nocrop,
        timestamp=get_timestamp(args.timestamp),
    )


    # set other metadata
    with open(f'{video_id}.info.json', encoding='utf-8') as metadata_json_file:
        metadata = json.load(metadata_json_file)
        set_metadata(metadata, audio_path, 'artist', 'artist', 'channel')
        set_metadata(metadata, audio_path, 'title', 'track', 'title')
        set_metadata(metadata, audio_path, 'album', 'album', 'track', 'title')


    # clean up temp files
    os.chdir("../")
    shutil.copyfile(f'{tempdir_path}/{video_id}.mp3', f'./{video_id}.mp3')
    if not args.keep:
        shutil.rmtree(tempdir_path)

if __name__ == '__main__':
    main()
